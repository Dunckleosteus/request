use std::fs::File;
use std::io::prelude::*;
use polars::prelude::*;
use std::io;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let _path3 = "https://catalogue.dataspace.copernicus.eu/odata/v1/Products?$filter=OData.CSC.Intersects(area=geography'SRID=4326;POLYGON((12.655118166047592 47.44667197521409,21.39065656328509 48.347694733853245,28.334291357162826 41.877123516783655,17.47086198383573 40.35854475076158,12.655118166047592 47.44667197521409))') and ContentDate/Start gt 2022-05-20T00:00:00.000Z and ContentDate/Start lt 2022-05-21T00:00:00.000Z";
    let _path4 = "https://catalogue.dataspace.copernicus.eu/odata/v1/Products?$filter=Data.CSC.Intersects(area=geography'SRID=4326;POLYGON((12.655118166047592 47.44667197521409,21.39065656328509 48.347694733853245,28.334291357162826 41.877123516783655,17.47086198383573 40.35854475076158,12.655118166047592 47.44667197521409))') and Name eq 'LANDSAT-5'";
    let _path5 = "https://catalogue.dataspace.copernicus.eu/odata/v1/Products?$filter=Collection/Name eq 'SENTINEL-2' and ContentDate/Start gt 2022-05-03T00:00:00.000Z and ContentDate/Start lt 2022-05-03T00:11:00.000Z";
    // trying to combine multiple parameters
    let _root = "https://catalogue.dataspace.copernicus.eu/odata/v1/Products?$filter=";
    let _date = "ContentDate/Start gt 2022-05-03T00:00:00.000Z and ContentDate/Start lt 2022-05-03T00:11:00.000Z";
    let _clouds = "Attributes/OData.CSC.DoubleAttribute/any(att:att/Name eq 'cloudCover' and att/OData.CSC.DoubleAttribute/Value le 40.00)";
    let _geography = "Data.CSC.Intersects(area=geography'SRID=4326;POLYGON((12.655118166047592 47.44667197521409,21.39065656328509 48.347694733853245,28.334291357162826 41.877123516783655,17.47086198383573 40.35854475076158,12.655118166047592 47.44667197521409))')";
    // this structure allows me to add and remove parameters one by one
    let query = format!("{}{} and {}", _root, _date, _clouds);

    let resp = reqwest::get(query)
        .await?
        .text() // Retrieve response as text
        .await?;

    // save text to file
    let mut file = File::create("foo.json")?;
    file.write_all(resp.as_bytes())?;
    print!("{}", json2dataframe("foo.json").unwrap());


    Ok(())
}
fn json2dataframe (path: &str) -> std::result::Result<polars::frame::DataFrame, PolarsError> {
    // this function converts the json format generated by the query into a polars dataframe
    // open the json file using serde_json
    let file = File::open(path).expect("Could not open json");
    let json: serde_json::Value = serde_json::from_reader(file).expect("file should be proper JSON");

    let dataset = &json["value"];
    let dataset_length = dataset.as_array().expect("Could not convert dataset to array").len();
    // define vecs
    let mut content_date: Vec<String> = Vec::new();
    let mut modification_date: Vec<String> = Vec::new();
    let mut name: Vec<String> = Vec::new();
    let mut origin_date: Vec<String> = Vec::new();
    let mut geom: Vec<String> = Vec::new();
    let mut id: Vec<String> = Vec::new();

    for index in 0..dataset_length {
        let value = &dataset[index];
        content_date.push((&value["ContentDate"]["Start"]).to_string()); 
        modification_date.push((&value["ModificationDate"]).to_string());
        name.push((&value["Name"]).to_string());
        origin_date.push((&value["OriginDate"]).to_string());
        geom.push((&value["GeoFootprint"]["coordinates"]).to_string());
        id.push((&value["Id"]).to_string());
    }
    // Make dataframe
    let df: DataFrame = df!(
        "Id" => &id,
        "Name" => &name,
        "ContentDate" => &content_date,
        "ModificationDate" => &modification_date,
        "OriginDate" => &origin_date,
        "geom" => &geom,
    )?;

    Ok(df)
}
